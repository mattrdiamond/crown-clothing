{"ast":null,"code":"// listens for every action of a specific type that we pass to it\nimport { takeEvery, call, put } from \"redux-saga/effects\";\nimport { firestore, convertCollectionsSnapshotToMap } from \"../../firebase/firebase.utils\";\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from \"./shop.actions\";\nimport ShopActionTypes from \"./shop.types\";\n/* Redux Saga Notes\n    • yield pauses execution until we call .next()\n    • takeEvery listens for specific action types and creates a non-blocking call to allow\n      app to continue running (doesn't pause js for async fetch calls to come back)\n    • We can also cancel yield actions -- if a second action gets called and sent to saga middleware before first\n      one completes, it can then determine whether or not to cancel first one from the second action that came in\n    • second param is another generator function that will run in response to action\n    • call() invokes method in first param, passing second param as argument\n    • put() is the saga effect for creating actions - exactly like dispatch, only requires yield */\n\nexport function* fetchCollectionsAsync() {\n  try {\n    const collectionRef = firestore.collection(\"collections\"); // 1. fetch snapshot obj from firestore\n\n    const snapshot = yield collectionRef.get(); // 2. convert snapshot's docs property (array) into new object, only including properties needed for front end\n\n    const colletionsMap = yield call(convertCollectionsSnapshotToMap, snapshot); // 3. Update reducer with collectionsMap and set isFetching to false\n\n    yield put(fetchCollectionsSuccess(collectionsMap));\n  } catch (error) {\n    yield put(fetchCollectionsFailure(error.message));\n  }\n}\nexport function* fetchCollectionsStart() {\n  // set isFetching to true, then start async saga\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}","map":{"version":3,"sources":["/Users/matt_diamond/Documents/Lynda/udacity/_nano/Projects/crown-clothing/src/redux/shop/shop.sagas.js"],"names":["takeEvery","call","put","firestore","convertCollectionsSnapshotToMap","fetchCollectionsSuccess","fetchCollectionsFailure","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","snapshot","get","colletionsMap","collectionsMap","error","message","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA;AACA,SAASA,SAAT,EAAoBC,IAApB,EAA0BC,GAA1B,QAAqC,oBAArC;AACA,SACEC,SADF,EAEEC,+BAFF,QAGO,+BAHP;AAIA,SACEC,uBADF,EAEEC,uBAFF,QAGO,gBAHP;AAIA,OAAOC,eAAP,MAA4B,cAA5B;AAEA;;;;;;;;;;AAUA,OAAO,UAAUC,qBAAV,GAAkC;AACvC,MAAI;AACF,UAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB,CADE,CAGF;;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAJE,CAKF;;AACA,UAAMC,aAAa,GAAG,MAAMZ,IAAI,CAACG,+BAAD,EAAkCO,QAAlC,CAAhC,CANE,CAOF;;AACA,UAAMT,GAAG,CAACG,uBAAuB,CAACS,cAAD,CAAxB,CAAT;AACD,GATD,CASE,OAAOC,KAAP,EAAc;AACd,UAAMb,GAAG,CAACI,uBAAuB,CAACS,KAAK,CAACC,OAAP,CAAxB,CAAT;AACD;AACF;AAED,OAAO,UAAUC,qBAAV,GAAkC;AACvC;AACA,QAAMjB,SAAS,CACbO,eAAe,CAACW,uBADH,EAEbV,qBAFa,CAAf;AAID","sourcesContent":["// listens for every action of a specific type that we pass to it\nimport { takeEvery, call, put } from \"redux-saga/effects\";\nimport {\n  firestore,\n  convertCollectionsSnapshotToMap\n} from \"../../firebase/firebase.utils\";\nimport {\n  fetchCollectionsSuccess,\n  fetchCollectionsFailure\n} from \"./shop.actions\";\nimport ShopActionTypes from \"./shop.types\";\n\n/* Redux Saga Notes\n    • yield pauses execution until we call .next()\n    • takeEvery listens for specific action types and creates a non-blocking call to allow\n      app to continue running (doesn't pause js for async fetch calls to come back)\n    • We can also cancel yield actions -- if a second action gets called and sent to saga middleware before first\n      one completes, it can then determine whether or not to cancel first one from the second action that came in\n    • second param is another generator function that will run in response to action\n    • call() invokes method in first param, passing second param as argument\n    • put() is the saga effect for creating actions - exactly like dispatch, only requires yield */\n\nexport function* fetchCollectionsAsync() {\n  try {\n    const collectionRef = firestore.collection(\"collections\");\n\n    // 1. fetch snapshot obj from firestore\n    const snapshot = yield collectionRef.get();\n    // 2. convert snapshot's docs property (array) into new object, only including properties needed for front end\n    const colletionsMap = yield call(convertCollectionsSnapshotToMap, snapshot);\n    // 3. Update reducer with collectionsMap and set isFetching to false\n    yield put(fetchCollectionsSuccess(collectionsMap));\n  } catch (error) {\n    yield put(fetchCollectionsFailure(error.message));\n  }\n}\n\nexport function* fetchCollectionsStart() {\n  // set isFetching to true, then start async saga\n  yield takeEvery(\n    ShopActionTypes.FETCH_COLLECTIONS_START,\n    fetchCollectionsAsync\n  );\n}\n"]},"metadata":{},"sourceType":"module"}