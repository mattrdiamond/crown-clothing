{"ast":null,"code":"import { takeLatest, call, put } from \"redux-saga/effects\";\nimport { firestore, convertCollectionsSnapshotToMap } from \"../../firebase/firebase.utils\";\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from \"./shop.actions\";\nimport ShopActionTypes from \"./shop.types\";\n/* Redux Saga Notes\n    • yield - yields control to saga so it can pause execution until we call .next()\n        • Also, if a second action gets called and sent to saga middleware before first one completes,\n          listener effect can then determine whether or not to cancel first one from the second action that came in\n    • Listener effects:\n        • takeEvery() - listens for specific action types and creates a non-blocking call on each action to allow\n          app to continue running (doesn't pause js for async fetch calls to come back)\n          • Allows multiple actions to be started concurrently\n          • second param is another generator function that will run in response to action\n        • take() - takes single action param. Promise resolves with payload value. Once generator function completes,\n          will not execute subsequent actions (done: true). take() is blocking vs takeEvery() which is non-blocking\n        • takeLatest() - allows only 1 task to run at a time (latest). Creates new saga instance for each action.\n          If you dispatch an action before previous API call finishes, it will automatically stop first call and only return latest\n    • call() invokes method in first param, passing second param as argument\n    • put() is the saga effect for creating actions - exactly like dispatch, only requires yield\n*/\n\nexport function* fetchCollectionsAsync() {\n  try {\n    const collectionRef = firestore.collection(\"collections\"); // 1. fetch snapshot obj from firestore\n\n    const snapshot = yield collectionRef.get(); // 2. convert snapshot's docs property (array) into new object, only including properties needed for front end\n\n    const collectionsMap = yield call(convertCollectionsSnapshotToMap, snapshot); // 3. Update reducer with collectionsMap and set isFetching to false\n\n    yield put(fetchCollectionsSuccess(collectionsMap));\n  } catch (error) {\n    yield put(fetchCollectionsFailure(error.message));\n  }\n}\nexport function* fetchCollectionsStart() {\n  // set isFetching to true, then start async saga\n  yield takeLatest(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}","map":{"version":3,"sources":["/Users/matt_diamond/Documents/Lynda/udacity/_nano/Projects/crown-clothing/src/redux/shop/shop.sagas.js"],"names":["takeLatest","call","put","firestore","convertCollectionsSnapshotToMap","fetchCollectionsSuccess","fetchCollectionsFailure","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","snapshot","get","collectionsMap","error","message","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,IAArB,EAA2BC,GAA3B,QAAsC,oBAAtC;AACA,SACEC,SADF,EAEEC,+BAFF,QAGO,+BAHP;AAIA,SACEC,uBADF,EAEEC,uBAFF,QAGO,gBAHP;AAIA,OAAOC,eAAP,MAA4B,cAA5B;AAEA;;;;;;;;;;;;;;;;;AAiBA,OAAO,UAAUC,qBAAV,GAAkC;AACvC,MAAI;AACF,UAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB,CADE,CAGF;;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAJE,CAKF;;AACA,UAAMC,cAAc,GAAG,MAAMZ,IAAI,CAC/BG,+BAD+B,EAE/BO,QAF+B,CAAjC,CANE,CAUF;;AACA,UAAMT,GAAG,CAACG,uBAAuB,CAACQ,cAAD,CAAxB,CAAT;AACD,GAZD,CAYE,OAAOC,KAAP,EAAc;AACd,UAAMZ,GAAG,CAACI,uBAAuB,CAACQ,KAAK,CAACC,OAAP,CAAxB,CAAT;AACD;AACF;AAED,OAAO,UAAUC,qBAAV,GAAkC;AACvC;AACA,QAAMhB,UAAU,CACdO,eAAe,CAACU,uBADF,EAEdT,qBAFc,CAAhB;AAID","sourcesContent":["import { takeLatest, call, put } from \"redux-saga/effects\";\nimport {\n  firestore,\n  convertCollectionsSnapshotToMap\n} from \"../../firebase/firebase.utils\";\nimport {\n  fetchCollectionsSuccess,\n  fetchCollectionsFailure\n} from \"./shop.actions\";\nimport ShopActionTypes from \"./shop.types\";\n\n/* Redux Saga Notes\n    • yield - yields control to saga so it can pause execution until we call .next()\n        • Also, if a second action gets called and sent to saga middleware before first one completes,\n          listener effect can then determine whether or not to cancel first one from the second action that came in\n    • Listener effects:\n        • takeEvery() - listens for specific action types and creates a non-blocking call on each action to allow\n          app to continue running (doesn't pause js for async fetch calls to come back)\n          • Allows multiple actions to be started concurrently\n          • second param is another generator function that will run in response to action\n        • take() - takes single action param. Promise resolves with payload value. Once generator function completes,\n          will not execute subsequent actions (done: true). take() is blocking vs takeEvery() which is non-blocking\n        • takeLatest() - allows only 1 task to run at a time (latest). Creates new saga instance for each action.\n          If you dispatch an action before previous API call finishes, it will automatically stop first call and only return latest\n    • call() invokes method in first param, passing second param as argument\n    • put() is the saga effect for creating actions - exactly like dispatch, only requires yield\n*/\n\nexport function* fetchCollectionsAsync() {\n  try {\n    const collectionRef = firestore.collection(\"collections\");\n\n    // 1. fetch snapshot obj from firestore\n    const snapshot = yield collectionRef.get();\n    // 2. convert snapshot's docs property (array) into new object, only including properties needed for front end\n    const collectionsMap = yield call(\n      convertCollectionsSnapshotToMap,\n      snapshot\n    );\n    // 3. Update reducer with collectionsMap and set isFetching to false\n    yield put(fetchCollectionsSuccess(collectionsMap));\n  } catch (error) {\n    yield put(fetchCollectionsFailure(error.message));\n  }\n}\n\nexport function* fetchCollectionsStart() {\n  // set isFetching to true, then start async saga\n  yield takeLatest(\n    ShopActionTypes.FETCH_COLLECTIONS_START,\n    fetchCollectionsAsync\n  );\n}\n"]},"metadata":{},"sourceType":"module"}